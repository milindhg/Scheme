#lang racket
(require C311/mk)
(provide (all-defined-out))


(define apply-Go
  (lambda (G e t)
    (fresh (a G^)
           (== `(,a . ,G^) G)
           (fresh (aa da)
                  (== `(,aa . ,da) a)
                  (conde
                   ((== aa e) (== da t))
                   ((=/= aa e) (apply-Go G^ e t)))))))

(define !-
  (lambda (G e t)
    (conde
     ((numbero e) (== 'Nat t))
     ((== t 'Bool)
      (conde
       ((== #t e))
       ((== #f e))))
     ((fresh (e1)
             (== `(not ,e1) e)
             (== 'Bool t)
             (!- G e1 'Bool)
             ))
     ((fresh (e1)
             (== `(zero? ,e1) e)
             (== 'Bool t)
             (!- G e1 'Nat)))
     ((fresh (e1)
             (== `(sub1 ,e1) e)
             (== 'Nat t)
             (!- G e1 'Nat)))
     ((fresh (ne1 ne2)
             (== `(+ ,ne1 ,ne2) e)
             (== 'Nat t)
             (!- G ne1 'Nat)
             (!- G ne2 'Nat)))
     ((fresh (ne1 ne2)
             (== `(* ,ne1 ,ne2) e)
             (== 'Nat t)
             (!- G ne1 'Nat)
             (!- G ne2 'Nat)))
     ((fresh (teste anse elsee)
             (== `(if ,teste ,anse ,elsee) e)
             (!- G teste 'Bool)
             (!- G anse t)
             (!- G elsee t)))
     ((symbolo e) (apply-Go G e t))
     ((fresh (x b)
             (== `(lambda (,x) ,b) e)
             (symbolo x)
             (fresh (tx tb)          
                    (== `(,tx -> ,tb) t)
                    (!- `((,x . ,tx) . ,G) b tb))))
     ((fresh (e1 arg)
             (== `(,e1 ,arg) e)
             (fresh (targ)
                    (!- G e1 `(,targ -> ,t))
                    (!- G arg targ))))
     ((fresh (x b)
             (== `(fix (lambda (,x) ,b)) e)
             (symbolo x)
             (!- `((,x . ,t) . ,G) b t)))
     ((fresh (e1 e2 t1 t2)
             (== `(cons ,e1 ,e2) e)
             (!- G e1 t1)
             (!- G e2 t2)
             (== `(pairof ,t1 ,t2) t)))
     ((fresh (ls)
             (== `(car ,ls) e)
             (fresh (t2)
                    (!- G ls `(pairof ,t ,t2)))))
     ((fresh (ls)
             (== `(cdr ,ls) e)
             (fresh (t2)
                    (!- G ls `(pairof ,t2 ,t))))))))


(run* (q) (!- '() '(cons (zero? 1) (zero? 0)) q))
;((pairof Bool Bool))
(run* (q) (!- '() '(cons (zero? 1) (cons (zero? 1) (zero? 0))) q))
;((pairof Bool (pairof Bool Bool)))
(run* (t) (!- '() '(lambda (x) (cons x x)) t))
;((_.0 -> (pairof _.0 _.0)))
(run* (t) (!- '() '(lambda (x) (lambda (y) (cons (zero? x) (+ x y)))) t))
;((Nat -> (Nat -> (pairof Bool Nat))))
(run* (t) (!- '() '(lambda (x) (zero? (car x))) t))
;(((pairof Nat _.0) -> Bool))
(run* (t) (!- '() '(lambda (x) (car x)) t))
;(((pairof _.0 _.1) -> _.1))
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons 0 1)) t))
;(Bool)
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons 0 #f)) t))
;(Bool)
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons #f 0)) t))
;()
;; a function that accepts a pair of anything and an Nat
(run* (t) (!- '() '(lambda (x) (zero? (cdr x))) t))
;(((pairof _.0 Nat) -> Bool))
(run* (t) (!- '() '(lambda (x) (cdr x)) t))
;(((pairof _.0 _.1) -> _.1))
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons 0 1)) t))
;(Bool)
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons 0 #f)) t))
;()
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons #f 0)) t))
;(Bool)

(printf "More Test Cases\n")


(run* (q) (!- '() '(cons (zero? 1) (zero? 0)) q))
;'((pairof Bool Bool)))
(run* (q) (!- '() '(cons (zero? 1) (cons (zero? 1) (zero? 0))) q))
; '((pairof Bool (pairof Bool Bool))))
(run* (t) (!- '() '(lambda (x) (cons x x)) t))
;'((_.0 -> (pairof _.0 _.0))))
(run* (t) (!- '() '(lambda (x) (lambda (y) (cons (zero? x) (+ x y)))) t))
;'((Nat -> (Nat -> (pairof Bool Nat)))))
(run* (t) (!- '() '(lambda (x) (zero? (car x))) t))
;'(((pairof Nat _.0) -> Bool)))
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons 0 1)) t))
;'(Bool))
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons 0 #f)) t))
;'(Bool))
(run* (t) (!- '() '((lambda (x) (zero? (car x))) (cons #f 0)) t))
;'())
(run* (t) (!- '() '(lambda (x) (zero? (cdr x))) t))
;'(((pairof _.0 Nat) -> Bool)))
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons 0 1)) t))
;'(Bool))
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons 0 #f)) t))
;'())
(run* (t) (!- '() '((lambda (x) (zero? (cdr x))) (cons #f 0)) t))
;'(Bool))
(run* (q)
 (!- '() '(let ([f (lambda (x) x)])
 (if (f #t) (f (cons (f 4) 5)) (f (cons 5 (f 6)))))
q))
;'((pairof Nat Nat)))

(run* (q) (!- '() '(((lambda (x) (lambda (y) (sub1 y))) 5) 6) q))

(run* (q) (!- '() '(lambda (!) (lambda (n) (if (zero? n) 1 (* n (! (sub1 n)))))) q))

(run* (q) (!- '() '(lambda (n) (if (zero? n) 1 2)) q))

(run* (q) (!- '() '(fix (lambda (k1) (lambda (n) (if (zero? n) 1 (k1 (sub1 n)))))) q))

(run* (q) (!- '() '(lambda (n) (if (zero? n) 1 2)) q))

(run* (q) (!- '() '(sub1) q))


(run* (q) (!- '() '(((lambda (x) (lambda (y) (sub1 y))) 5) 6) q))
