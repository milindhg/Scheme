#lang racket
(require C311/pmatch)
(require C311/trace)



(define value-of-fn
 (lambda (exp env)
  (pmatch exp
   (`,n (guard (number? n)) n)
   (`,x (guard (symbol? x)) (apply-env env x))
   (`,b (guard (boolean? b)) b)
   (`(zero? ,n-exp) (zero? (value-of-fn n-exp env)))
   (`(* ,x ,y) (* (value-of-fn x env) (value-of-fn y env)))
   (`(let ([ ,x ,val ]) ,body) (value-of-fn body (extend-env x (value-of-fn val env) env)))
   (`(sub1 ,x) (sub1 (value-of-fn x env)))
   (`(if ,test-exp ,then-exp ,else-exp) (if (value-of-fn test-exp env) (value-of-fn then-exp env) (value-of-fn else-exp env)))
   (`(lambda (,x) ,body) (closure x body env))
   (`(,rator ,rand) (apply-closure (value-of-fn rator env) (value-of-fn rand env))))))

(define empty-env
 (lambda ()
  (lambda (y)
   (error 'value-of "unbound variable ~s" y))))

(define extend-env
 (lambda (x a env)
  (lambda (y)
   (if (eqv? x y) a (apply-env-fn env y)))))

(define apply-env
 (lambda (env y)
  (env y)))

(define closure
 (lambda (x body env)
  (lambda (a)
   (value-of-fn body (extend-env x a env)))))

(define apply-closure
 (lambda (p a)
  (p a)))
